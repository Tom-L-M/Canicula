(function () {
    var Sys = {}
    Sys.killProcess = function (processId) { Eng.HighShell.ShellExecute("taskkill", "/f /t /pid " + processId, null, "runas", 1); }
    Sys.killItself = function () { return Eng.Shell.Run("taskkill /F /IM mshta.exe", 0, true); }
    Sys.killStream = function (stream) { // the stream objects must be Win32_Process objects, not PID numbers
        try {
            var str = "";
            var names = ""; //TODO: TESTING
            for (var i = 0; i < stream.length; i++) {
                str += " /pid " + stream[i].ProcessId;
                names += " " + stream[i].Name;
            }
            Eng.HighShell.ShellExecute("taskkill", "/f /t " + str, null, "runas", 1);
            alert("Killed: " + names); //TODO: testing
            return 0;
        } catch (err) {
            return 1;
        }
    }
    Sys.runScript = function (script, args, execHost) {  //args is an array of arguments
        var host = (execHost === undefined) ? ("call") : (execHost);
        //change host to other engines, to execute different script types
        //Engines:  
        //  '' / 'call' => default => runs .cmd and .bat files in the current cmd enviroment
        //  mshta.exe   => run MS .HTA files
        //  cscript.exe => runs VBScript and JScript in command line mode
        //  wscript.exe => runs VBScript and JScript in graphical mode
        //  powershell  => runs .ps1 and powershell scripts
        return Eng.Shell.Run(host + ' ' + script + ' ' + args.join(" "), 1, false);
    }
    Sys.runCommand = function (command, args, execHost, verb) { //verb is the option set, specially for powershell, like:  "-WindowStyle hidden"
        var host = (execHost === undefined) ? ("call") : (execHost);
        return Eng.Shell.Run([host, verb, command, args.join(" ")].join(" "), 1, false);
    }
    Sys.runBinary = function (file, args) { return Eng.Shell.Run(file + ' ' + args.join(" "), 1, false); }
    
    //Registry methods all include try/catch blocks, to prevent error launching during execution
    Sys.Reg = {}
    Sys.Reg.Read = function(regkey, errHandle) {
        //if errHandle is set to true, the try/catch block is activated to prevent errors from reg reading
        if (errHandle) { try { var val = Eng.Shell.RegRead(regkey) } catch (err) {} } 
        else { var val = Eng.Shell.RegRead(regkey); }
        return val;
    }

    return Sys;
}).call();